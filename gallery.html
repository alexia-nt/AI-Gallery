<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Gallery Room</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: white;
        }

        canvas {
            display: block;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #fff;
            z-index: 10;
        }

        #instructions {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .instruction-text {
            font-size: 1.5rem;
            margin-bottom: 20px;
        }

        .instruction-controls {
            font-size: 1rem;
            line-height: 1.5;
            color: #aaa;
        }

        #modal-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 20;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        #modal-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 90%;
            max-height: 90%;
            position: relative;
            background-color: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        #modal-image {
            max-width: 100%;
            max-height: 50vh;
            border-radius: 8px;
            object-fit: contain;
        }
        
        #modal-text {
            color: white;
            text-align: center;
            padding: 20px;
            max-width: 800px;
        }
        
        #modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        #modal-poem {
            font-style: italic;
            margin-top: 10px;
            line-height: 1.4;
        }
        
        #close-button {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #fff;
            color: #000;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 1.5rem;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease-in-out;
            user-select: none;
        }
        #close-button:hover {
            transform: scale(1.1);
        }
        
        #cursor {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background-color: #ccc;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
        }
        
        #cursor.active {
            background-color: #4CAF50;
        }
        
        @media (max-width: 768px) {
            .instruction-text {
                font-size: 1.2rem;
            }
            .instruction-controls {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>

    <div id="blocker">
        <div id="instructions">
            <p class="instruction-text">Click to Play</p>
            <p class="instruction-controls">
                Use WASD or arrow keys to move<br/>
                Mouse to look around<br/>
                Look for the green cursor to click a picture<br/>
                ESC to exit<br/>
                <br/>
                Press M to toggle background music
            </p>
        </div>
    </div>

    <div id="modal-container">
        <div id="modal-content">
            <img id="modal-image" src="" alt="Gallery Image">
            <div id="modal-text">
                <div id="modal-title"></div>
                <div id="modal-poem"></div>
            </div>
            <span id="close-button">&times;</span>
        </div>
    </div>
    
    <div id="cursor"></div>

    <canvas id="three-canvas"></canvas>

    <script>
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */

    const PointerLockControls = function ( camera, domElement ) {

        if ( domElement === undefined ) {

            console.warn( 'THREE.PointerLockControls: The second parameter "domElement" is now mandatory.' );
            domElement = document.body;

        }

        //
        // internals
        //

        const scope = this;
        const euler = new THREE.Euler( 0, 0, 0, 'YXZ' );
        const PI_2 = Math.PI / 2;
        scope.isLocked = false;

        const connect = function () {

            domElement.ownerDocument.addEventListener( 'mousemove', onMouseMove, false );
            domElement.ownerDocument.addEventListener( 'pointerlockchange', onPointerlockChange, false );
            domElement.ownerDocument.addEventListener( 'pointerlockerror', onPointerlockError, false );

        };

        const disconnect = function () {

            domElement.ownerDocument.removeEventListener( 'mousemove', onMouseMove, false );
            domElement.ownerDocument.removeEventListener( 'pointerlockchange', onPointerlockChange, false );
            domElement.ownerDocument.removeEventListener( 'pointerlockerror', onPointerlockError, false );

        };

        const dispose = function () {

            disconnect();

        };

        const onMouseMove = function ( event ) {

            if ( scope.isLocked === false ) return;

            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            euler.setFromQuaternion( camera.quaternion );

            euler.y -= movementX * 0.002;
            euler.x -= movementY * 0.002;

            euler.x = Math.max( - PI_2, Math.min( PI_2, euler.x ) );

            camera.quaternion.setFromEuler( euler );

            scope.dispatchEvent( { type: 'change' } );

        };

        const onPointerlockChange = function () {

            if ( domElement.ownerDocument.pointerLockElement === domElement ) {

                scope.dispatchEvent( { type: 'lock' } );

                scope.isLocked = true;

            } else {

                scope.dispatchEvent( { type: 'unlock' } );

                scope.isLocked = false;

            }

        };

        const onPointerlockError = function () {

            console.error( 'THREE.PointerLockControls: Unable to use Pointer Lock API' );

        };

        //
        // public API
        //

        this.domElement = domElement;

        this.lock = function () {

            this.domElement.requestPointerLock();

        };

        this.unlock = function () {

            this.domElement.ownerDocument.exitPointerLock();

        };

        this.getObject = function () {

            return camera;

        };

        const vector = new THREE.Vector3();

        this.getDirection = function () {
            // assumes the camera's up vector is the Y axis
            return function ( v ) {
                v.set( 0, 0, - 1 ).applyQuaternion( camera.quaternion );
                return v;
            };
        }();


        this.moveForward = function ( distance ) {
            // move forward parallel to the xz-plane
            vector.setFromMatrixColumn( camera.matrix, 0 );
            vector.crossVectors( camera.up, vector );
            camera.position.addScaledVector( vector, distance );
        };


        this.moveRight = function ( distance ) {
            vector.setFromMatrixColumn( camera.matrix, 0 );
            camera.position.addScaledVector( vector, distance );
        };

        this.connect = connect;
        this.disconnect = disconnect;
        this.connect(); // Automatically connect
    };

    PointerLockControls.prototype = Object.create( THREE.EventDispatcher.prototype );
    PointerLockControls.prototype.constructor = PointerLockControls;
    </script>
    <script>
        // --- Basic setup ---
        const canvas = document.getElementById('three-canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);

        // --- Controls ---
        const controls = new PointerLockControls(camera, document.body);
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const cursor = document.getElementById('cursor');

        instructions.addEventListener('click', () => {
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            blocker.style.display = 'none';
            renderer.domElement.focus();
            cursor.style.display = 'block';
        });

        controls.addEventListener('unlock', () => {
            blocker.style.display = 'flex';
            cursor.style.display = 'none';
        });

        // --- Movement variables ---
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;

        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        });

        // Artwork data
        const artworks = [
            {
                url: 'Artworks/1.jpeg',
                title: '1. A Brand New Start',
                poem: 'One step away, the world rewinds,\nyet forward pulls the tethered mind.\nDreams outweigh the fear of loss.'
            },
            {
                url: 'https://placehold.co/800x600/222/FFF?text=The+Unfamiliar+Grocery+Aisle',
                title: '2. The Unfamiliar Grocery Aisle',
                poem: 'These words are strange, the names untold,\nA simple errand feels so bold.\nA map of food I must now learn,\nFor simple comfort, I must yearn.'
            },
            {
                url: 'https://placehold.co/800x600/222/FFF?text=The+Broken+Conversation',
                title: '3. The Broken Conversation',
                poem: 'My thoughts are clear, my voice is not,\nEach phrase a struggle, a knotted plot.\nI search for words, they slip and slide,\nA different me I try to hide.'
            },
            {
                url: 'https://placehold.co/600x800/222/FFF?text=The+Silent+Bus+Window',
                title: '4. The Silent Bus Window',
                poem: 'A glass between this world and me,\nA sea of faces I can\'t see.\nThe city lights rush by in streaks,\nA silent story that the glass speaks.'
            },
            {
                url: 'https://placehold.co/600x800/222/FFF?text=The+Empty+Chair',
                title: '5. The Empty Chair',
                poem: 'The work waits here, the book is open,\nBut thoughts of home feel bittersweet, unspoken.\nA screen holds faces I can\'t touch,\nAnd oh, I miss their warmth so much.'
            },
            {
                url: 'https://placehold.co/600x800/222/FFF?text=Test',
                title: '6. Test',
                poem: 'One step away, the world rewinds,\nyet forward pulls the tethered mind.\nDreams outweigh the fear of loss.'
            },
            {
                url: 'https://placehold.co/800x600/222/FFF?text=The+New+Routine',
                title: '7. The New Routine',
                poem: 'These new small habits, strange before,\nNow fit like keys to an unlocked door.\nThe awkward pause begins to fade,\nA simple life is being made.'
            },
            {
                url: 'https://placehold.co/600x800/222/FFF?text=The+Memory+of+a+Scent',
                title: '8. The Memory of a Scent',
                poem: 'A passing scent, a sudden grace,\nTransported to a different place.\nA ghost of home that lingers on,\nA bittersweet and tender dawn.'
            },
            {
                url: 'https://placehold.co/800x600/222/FFF?text=The+Circle+of+Belonging',
                title: '9. The Circle of Belonging',
                poem: 'My story\'s threads begin to weave,\nNew friends and family I receive.\nA chosen home, a second chance,\nTo join the rhythm, learn the dance.'
            },
            {
                url: 'https://placehold.co/800x600/222/FFF?text=The+Reflected+Face',
                title: '10. The Reflected Face',
                poem: 'I stand before the self I\'ve grown,\nThe path I\'ve walked, the seeds I\'ve sown.\nMy past and future, side by side,\nBetween two worlds, I now reside.'
            }
        ];

        // --- Gallery Objects ---
        const galleryObjects = [];

        // A function to create a wall with a texture
        function createWall(width, height, depth, color, position) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshLambertMaterial({ color });
            const wall = new THREE.Mesh(geometry, material);
            wall.position.copy(position);
            scene.add(wall);
        }

        // A function to create a picture plane with a placeholder image and metadata
        function createPicturePlane(artworkData, width, height, position, rotation) {
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(artworkData.url);
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({ map: texture });
            const picture = new THREE.Mesh(geometry, material);
            picture.position.copy(position);
            picture.rotation.copy(rotation);
            // Store all the artwork data in the user data property of the mesh
            picture.userData = artworkData;
            scene.add(picture);
            galleryObjects.push(picture);
        }

        // Create the room
        const roomWidth = 60;
        const roomHeight = 40;
        const roomDepth = 80;

        // Floor and ceiling
        // createWall(roomWidth, 1, roomDepth, 0x555555, new THREE.Vector3(0, -roomHeight / 2, 0));
        // createWall(roomWidth, 1, roomDepth, 0x555555, new THREE.Vector3(0, roomHeight / 2, 0));

        // --- Modern textured floor ---
        const textureLoader = new THREE.TextureLoader();
        const floorTexture = textureLoader.load('textures/floor1.jpg'); // Replace with any modern floor texture URL
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(4, 4); // Adjust how many times the texture repeats
        floorTexture.anisotropy = 16; // Improves texture quality at angles

        const floorGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            map: floorTexture,
            roughness: 0.6, // Matte look
            metalness: 0.2  // Slight reflective feel
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2; // Lay flat
        floor.position.y = -roomHeight / 2 + 0.5; // Same height as old floor
        scene.add(floor);

        // Ceiling
        
        // 1. Load a ceiling texture
        const ceilingTexture = textureLoader.load('textures/wall.jpg'); // Replace with your ceiling texture URL
        ceilingTexture.wrapS = THREE.RepeatWrapping;
        ceilingTexture.wrapT = THREE.RepeatWrapping;
        ceilingTexture.repeat.set(3, 3); // Adjust repetition as needed
        ceilingTexture.anisotropy = 16;

        // 2. Create a material for the ceiling
        const ceilingMaterial = new THREE.MeshStandardMaterial({
            map: ceilingTexture,
            roughness: 0.7, // slightly matte
            metalness: 0.1
        });
        

        // 3. Create a ceiling mesh
        const ceilingGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
        const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
        ceiling.rotation.x = Math.PI / 2; // Flip so it faces down
        ceiling.position.y = roomHeight / 2; // Top of the room
        scene.add(ceiling);

        // Walls
        // createWall(1, roomHeight, roomDepth, 0x888888, new THREE.Vector3(-roomWidth / 2, 0, 0));
        // createWall(1, roomHeight, roomDepth, 0x888888, new THREE.Vector3(roomWidth / 2, 0, 0));
        // createWall(roomWidth, roomHeight, 1, 0x888888, new THREE.Vector3(0, 0, -roomDepth / 2));
        // createWall(roomWidth, roomHeight, 1, 0x888888, new THREE.Vector3(0, 0, roomDepth / 2));

        // --- Textured Walls ---

        // Load wall textures
        const wallTexture = textureLoader.load('textures/wall.jpg'); // Replace with any modern wall texture URL
        wallTexture.wrapS = THREE.RepeatWrapping;
        wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.repeat.set(4, 2); // Adjust based on your room size

        // Create a material with the texture
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            map: wallTexture,
            roughness: 0.7,
            metalness: 0.1
        });

        // Function to create textured walls
        function createTexturedWall(width, height, depth, position, rotation) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const wall = new THREE.Mesh(geometry, wallMaterial);
            wall.position.copy(position);
            
            if (rotation) {
                wall.rotation.copy(rotation);
            }
            
            scene.add(wall);
            return wall;
        }

        // Walls
        createTexturedWall(1, roomHeight, roomDepth, new THREE.Vector3(-roomWidth / 2, 0, 0));
        createTexturedWall(1, roomHeight, roomDepth, new THREE.Vector3(roomWidth / 2, 0, 0));
        createTexturedWall(roomWidth, roomHeight, 1, new THREE.Vector3(0, 0, -roomDepth / 2));
        createTexturedWall(roomWidth, roomHeight, 1, new THREE.Vector3(0, 0, roomDepth / 2));


        // Lighting
        const ambientLight = new THREE.AmbientLight(0xfff7ed, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xfff7ed, 0.5, 100);
        pointLight.position.set(0, roomHeight / 2 - 2, 0);
        scene.add(pointLight);

        // Add pictures from the artworks array
        const picSize = 10; // 5
        const picHeight = -3;
        const halfPI = Math.PI / 2;
        
        // Left Wall
        createPicturePlane(artworks[9], picSize, picSize, new THREE.Vector3(-roomWidth / 2 + 1, picHeight, -20), new THREE.Euler(0, halfPI, 0));
        createPicturePlane(artworks[8], picSize, picSize, new THREE.Vector3(-roomWidth / 2 + 1, picHeight, 0), new THREE.Euler(0, halfPI, 0));
        createPicturePlane(artworks[7], picSize, picSize, new THREE.Vector3(-roomWidth / 2 + 1, picHeight, 20), new THREE.Euler(0, halfPI, 0));

        // Right Wall
        createPicturePlane(artworks[2], picSize, picSize, new THREE.Vector3(roomWidth / 2 - 1, picHeight, -20), new THREE.Euler(0, -halfPI, 0));
        createPicturePlane(artworks[3], picSize, picSize, new THREE.Vector3(roomWidth / 2 - 1, picHeight, 0), new THREE.Euler(0, -halfPI, 0));
        createPicturePlane(artworks[4], picSize, picSize, new THREE.Vector3(roomWidth / 2 - 1, picHeight, 20), new THREE.Euler(0, -halfPI, 0));

        // Front Wall
        createPicturePlane(artworks[0], picSize, picSize, new THREE.Vector3(-12, picHeight, -roomDepth / 2 + 1), new THREE.Euler(0, 0, 0));
        createPicturePlane(artworks[1], picSize, picSize, new THREE.Vector3(12, picHeight, -roomDepth / 2 + 1), new THREE.Euler(0, 0, 0));

        // Back Wall
        createPicturePlane(artworks[5], picSize, picSize, new THREE.Vector3(-19, picHeight, roomDepth / 2 - 1), new THREE.Euler(0, Math.PI, 0));
        createPicturePlane(artworks[6], picSize, picSize, new THREE.Vector3(19, picHeight, roomDepth / 2 - 1), new THREE.Euler(0, Math.PI, 0));

        // Door in the center of the back wall
        const doorTexture = textureLoader.load('Images/door2.png');
        const doorGeometry = new THREE.PlaneGeometry(30, 30); // width, height (make it taller than artworks)
        // const doorMaterial = new THREE.MeshBasicMaterial({ map: doorTexture });
        const doorMaterial = new THREE.MeshBasicMaterial({ 
            map: doorTexture,
            transparent: true,   // allow transparency
            alphaTest: 0.5       // discard fully transparent pixels
        });
        const door = new THREE.Mesh(doorGeometry, doorMaterial);

        door.position.set(0, -6, roomDepth / 2 - 1); // X=0 (center), Y=5 (floor alignment), Z=back wall
        door.rotation.y = Math.PI; // face into the room

        scene.add(door);

        // -----------------------------------------------------

        // Load lamp texture
        const lampTexture = new THREE.TextureLoader().load('Images/lamp.png');

        // Create a plane for the lamp
        const lampMaterial = new THREE.MeshBasicMaterial({
            map: lampTexture,
            transparent: true,   // allow transparency in PNG
            side: THREE.DoubleSide
        });

        const lampSize = 10; // adjust size as needed
        const lamp = new THREE.Mesh(
            new THREE.PlaneGeometry(lampSize, lampSize),
            lampMaterial
        );

        // Position it on the ceiling, same as point light
        lamp.position.set(0, roomHeight / 2 - 0.01, 0); // slightly below ceiling
        lamp.rotation.x = Math.PI / 2; // face downward
        scene.add(lamp);

        // -----------------------------------------------------

        // --- Load GLB Model ---
        const gltfLoader = new THREE.GLTFLoader();

        gltfLoader.load('models/yourModel.glb', function(gltf) {
            const model = gltf.scene;

            model.position.set(15, -roomHeight / 2 + 11, 10);
            model.scale.set(10, 10, 10);
            model.rotation.y = Math.PI / 4;

            // Force the model to be visible with basic materials
            model.traverse((child) => {
                if (child.isMesh) {
                    // Use MeshBasicMaterial which doesn't need lights
                    child.material = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        map: child.material.map // preserve texture if it exists
                    });
                }
            });

            // Make it clickable
            model.userData = {
                title: "3D Sculpture",
                poem: "A mysterious sculpture stands here,\ninviting contemplation and awe."
            };
            // galleryObjects.push(model);

            scene.add(model);

            // Create bounding box
            modelBoundingBox = new THREE.Box3().setFromObject(model);
        });

        // camera.position.set(0, picHeight, 0);

        const eyeHeight = 15; // playerâ€™s eye level above the floor
        camera.position.set(0, -roomHeight / 2 + eyeHeight, 0);

        // --- Raycasting for interaction ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const modalContainer = document.getElementById('modal-container');
        const modalImage = document.getElementById('modal-image');
        const modalTitle = document.getElementById('modal-title');
        const modalPoem = document.getElementById('modal-poem');
        const closeButton = document.getElementById('close-button');

        window.addEventListener('click', (event) => {
            if (controls.isLocked) {
                // Raycast straight ahead from the camera
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); // center of the screen

                const intersects = raycaster.intersectObjects(galleryObjects);

                if (intersects.length > 0) {
                    const clickedObject = intersects[0].object;
                    modalImage.src = clickedObject.userData.url;
                    modalTitle.textContent = clickedObject.userData.title;
                    // modalPoem.textContent = clickedObject.userData.poem;
                    modalPoem.innerHTML = clickedObject.userData.poem.replace(/\n/g, '<br>');
                    modalContainer.style.display = 'flex';
                    controls.unlock();
                }
            }
        });

        closeButton.addEventListener('click', () => {
            modalContainer.style.display = 'none';
            controls.lock(); // Re-lock controls after modal is closed
        });

        // --------------------------------------------------------

        // --- Footstep audio setup ---
        const footstepFiles = [
            'audio/footstep1.mp3',
            'audio/footstep2.mp3',
            'audio/footstep3.mp3'
        ];

        let footstepAudio = new Audio();
        footstepAudio.volume = 0.8;
        footstepAudio.loop = true; // will loop while moving
        let isWalking = false;

        // Function to start footsteps
        function startFootsteps() {
            if (!isWalking) {
                // Pick a random footstep sound
                const file = footstepFiles[Math.floor(Math.random() * footstepFiles.length)];
                footstepAudio.src = file;
                footstepAudio.currentTime = 0;
                footstepAudio.playbackRate = 1.1; // speed up the sound
                footstepAudio.play();
                isWalking = true;
            }
        }

        // Function to stop footsteps
        function stopFootsteps() {
            if (isWalking) {
                footstepAudio.pause();
                footstepAudio.currentTime = 0; // reset to start
                isWalking = false;
            }
        }

        // --------------------------------------------------------

        // --- Game loop ---
        let prevTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            // Determine if the player is moving
            const moving = moveForward || moveBackward || moveLeft || moveRight;

            if (moving) {
                startFootsteps();
            } else {
                stopFootsteps();
            }
            
            // --- ADDED CODE FOR BOUNDARY CHECKS ---
            const halfRoomWidth = roomWidth / 2;
            const halfRoomDepth = roomDepth / 2;
            const padding = 1.0; // A small buffer to prevent z-fighting with the walls
            
            // --- ADDED CODE FOR COLLISIONS ---
            // 1. **GLB Model Collision Check**
            if (modelBoundingBox) {
                const playerPos = camera.position;
                
                // Create a smaller bounding box for collision (slightly smaller than the model)
                const collisionBox = modelBoundingBox.clone();
                const shrinkFactor = 0.8; // Adjust this value to change collision boundary size
                collisionBox.min.multiplyScalar(shrinkFactor);
                collisionBox.max.multiplyScalar(shrinkFactor);
                
                // Check if player is inside the collision box
                if (collisionBox.containsPoint(playerPos)) {
                    // Calculate the direction from model center to player
                    const modelCenter = new THREE.Vector3();
                    collisionBox.getCenter(modelCenter);
                    const direction = new THREE.Vector3().subVectors(playerPos, modelCenter).normalize();
                    
                    // Find the closest face to push player out
                    const distances = [
                        Math.abs(playerPos.x - collisionBox.min.x),
                        Math.abs(playerPos.x - collisionBox.max.x),
                        Math.abs(playerPos.z - collisionBox.min.z),
                        Math.abs(playerPos.z - collisionBox.max.z)
                    ];
                    
                    const minDistance = Math.min(...distances);
                    const minIndex = distances.indexOf(minDistance);
                    
                    // Push player out based on the closest face
                    switch(minIndex) {
                        case 0: // Left face
                            camera.position.x = collisionBox.min.x - 0.1;
                            break;
                        case 1: // Right face
                            camera.position.x = collisionBox.max.x + 0.1;
                            break;
                        case 2: // Front face
                            camera.position.z = collisionBox.min.z - 0.1;
                            break;
                        case 3: // Back face
                            camera.position.z = collisionBox.max.z + 0.1;
                            break;
                    }
                    
                    // Reset velocity to prevent continuous pushing
                    velocity.x = 0;
                    velocity.z = 0;
                }
            }
            // --- END OF ADDED CODE ---
            

            // Clamp the camera's X position
            if (camera.position.x < -halfRoomWidth + padding) {
                camera.position.x = -halfRoomWidth + padding;
            }
            if (camera.position.x > halfRoomWidth - padding) {
                camera.position.x = halfRoomWidth - padding;
            }

            // Clamp the camera's Z position
            if (camera.position.z < -halfRoomDepth + padding) {
                camera.position.z = -halfRoomDepth + padding;
            }
            if (camera.position.z > halfRoomDepth - padding) {
                camera.position.z = halfRoomDepth - padding;
            }
            // --- END OF ADDED CODE ---

            // Check if the raycaster intersects with any of the gallery objects
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(galleryObjects);
            if (intersects.length > 0) {
                cursor.classList.add('active');
            } else {
                cursor.classList.remove('active');
            }

            renderer.render(scene, camera);
            prevTime = time;
        }

        animate();

        // --- Resize handler ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Load audio
        const bgMusic = new Audio('audio/background.mp3');
        bgMusic.loop = true;  // keep playing in a loop
        bgMusic.volume = 0.5; // adjust volume (0.0 to 1.0)

        // Toggle music with "M"
        window.addEventListener('keydown', (event) => {
            if (event.key.toLowerCase() === 'm') {
                if (bgMusic.paused) {
                    bgMusic.play();
                } else {
                    bgMusic.pause();
                }
            }
        });
    </script>
</body>
</html>
